---
title: 硬件学习笔记
description: 杭州宏杉硬件学习笔记
#cover: /cover/cover2.png
tag:
- 杭州宏杉
- 服务器
- 硬件
  #sticky: 999
date: 2025-07-8 17:03
---

# 服务器硬件基本概念

## 服务器概念

* 服务器分类：
  * 按指令集分：**CISC复杂指令集**服务器（X86架构）、**RISC精简指令集**服务器（非X86架构）
  * 按外形分：塔式（形似家用主机）、机架式、刀片式、高密
  ![按外形分类](images/image1.png)
  * 按处理器数量分：单路服务器（1颗CPU）、双路服务器（2颗CPU）、多路服务器（4颗及以上CPU）

* BIOS的功能：**计算机启动时加载的第一个软件**，主要用于POST自检，检测输入输出设备和可启动设备，包括内存初始化、硬件扫描和寻找启动设备、启动系统，高级电源管理，配置RAID，查看系统信息。在Linux系统中，可以使用指令`sudo dmidecode -t bios`查看bios的相关信息
  
* UEFI和Legacy模式：
  * **主流服务器BIOS默认为UEFI模式**，相较于传统的Legacy，可以支持从大于2.2T的GPT格式硬盘引导，支持网络PXE引导，提供UEFI Shell环境
  * 没有特殊需求一般为UEFI模式，**备份则为Legacy模式**

* BMC（基板管理控制器）：用于监控和管理服务器的专用控制器，它是一个**独立的系统**，只要上电BMC软件就能快速运转起来，主要功能包括：
  * **设备信息管理**：记录服务器型号，制造商，日期，主板信息等，BMC可以通过Web界面方式查看系统信息
  * **服务器状态监控管理**：对服务器的CPU、内存、硬盘、风扇、机框等部件的温度、电压等健康状态进行管理
  * **服务器远程控制**：服务器开关机、重启、维护、固件更新、系统安装等
  * **维护管理**：日志管理，用户管理，BIOS管理，告警管理等
  ![alt text](images/image.png)

* IPMI：是一组交互标准管理规范，其实就是BMC系统，可独立运行的板上部件，主要用于服务器系统集群自治，监视服务器的物理健康状态，同时还负责记录各种硬件的信息和日志记录
  
* redfish：是IPMI规范的新一代标准，它基于**HTTPS**服务的管理标准，利用restful接口实现设备管理。与IPMI相比更简单，更安全（基于HTTPS）
  
* CPU缓存：为CPU和内存之间的临时存储器，目前的CPU拥有三级缓存。缓存具有极快的存取速度，它是硬盘与外部接口之间的缓冲器。

* CPU的频率：**主频 = 外频 * 倍频** **主频为CPU的额定工作频率**，主频越高，CPU性能越好
  * 外频（Base Clock）为CPU的**基准时钟频率**，单位为`MHz`
  * 倍频是指CPU主频与外频之间的**相对比例**关系，是CPU内部的一个放大系数
  * 在Linux中可以使用`lscpu`指令查看cpu的相关参数或查看`/proc/cpuinfo`文件
  
* 超线程：一颗CPU同时执行多个程序且共同分享一颗CPU内的资源。当两个线程都同时需要某一资源时，其中一个要暂时停止，并让出资源，知道资源闲置后才能继续，因此超线程的性能并等于两颗CPU的性能

* CPU相关概念：
  * 物理CPU：即主板上插了几块CPU，查看指令：
  
  ```sh
  cat /proc/cpuinfo | grep "physical id" // 查看所有的id，有多少个id就有多少个CPU
  ```

  * CPU物理核心（core）：一颗物理CPU中包含的核心数量（**6核**12线程），查看指令：

  ```sh
  cat /proc/cpuinfo | grep "cpu cores" // 直接查看cpu cores的值，也就是核心数量
  cat /proc/cpuinfo | grep "core id" // 查看核心id，有多少个id就有多少个核心
  ```

  * CPU逻辑核数（线程数）：通过超线程技术，将一个物理核心分成多个逻辑核心（6核**12线程**），查看指令：
  
  ```sh
  cat /proc/cpuinfo | grep "processor" | sort -u | wc -l // sort为对文本进行排序 -u 参数为对结果去重（unique），wc（words count）为文本统计 -l 参数则是统计行数（line）
  ```

  * CPU中断：系统发生了非寻常的急需处理事件，CPU短暂中断当前执行的程序转而去执行相应的事件处理程序，处理完毕后返回原来被中断处继续执行。
  